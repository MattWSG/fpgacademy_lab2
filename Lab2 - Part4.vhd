LIBRARY ieee;
USE ieee.std_logic_1164.all;

--
-- Based upon Golden_top generated by Terasic System Builder
-- Sourced from janaite on GitHub
--
ENTITY top IS
	Port (
		-- CLOCK
		ADC_CLK_10 		: in std_logic;
		MAX10_CLK1_50 	: in std_logic;
		MAX10_CLK2_50 	: in std_logic;

		-- SDRAM
		DRAM_DQ 		: in std_logic_vector(15 downto 0);
		DRAM_ADDR 	: out std_logic_vector(12 downto 0);
		DRAM_BA 		: out std_logic_vector(1 downto 0);
		DRAM_CAS_N 	: out std_logic;
		DRAM_CKE 	: out std_logic;
		DRAM_CLK 	: out std_logic;
		DRAM_CS_N 	: out std_logic;
		DRAM_LDQM 	: out std_logic;
		DRAM_RAS_N 	: out std_logic;
		DRAM_UDQM 	: out std_logic;
		DRAM_WE_N 	: out std_logic;

		-- SEG7
		HEX0 : out std_logic_vector (7 downto 0) := (others => '1');
		HEX1 : out std_logic_vector (7 downto 0) := (others => '1');
		HEX2 : out std_logic_vector (7 downto 0) := (others => '1');
		HEX3 : out std_logic_vector (7 downto 0) := (others => '1');
		HEX4 : out std_logic_vector (7 downto 0) := (others => '1');
		HEX5 : out std_logic_vector (7 downto 0) := (others => '1');

		-- KEY
		KEY : in std_logic_vector (1 downto 0);

		-- LED
		LEDR 	: out std_logic_vector (9 downto 0);

		-- SW
		SW : in 	std_logic_vector (9 downto 0);

		-- VGA
		VGA_B 	:  out std_logic_vector (3 downto 0);
		VGA_G 	:  out std_logic_vector (3 downto 0);
		VGA_HS	:  out std_logic;
		VGA_R 	:  out std_logic_vector (3 downto 0);
		VGA_VS 	:  out std_logic;

		
		-- Accelerometer
		GSENSOR_CS_N 	: out std_logic;
		GSENSOR_SCLK 	: out std_logic;
		GSENSOR_INT 	: in std_logic_vector (2 downto 1); 
		GSENSOR_SDI 	: in std_logic;
		GSENSOR_SDO 	: in std_logic;

		-- Arduino
		ARDUINO_IO 			: in std_logic_vector (15 downto 0);
		ARDUINO_RESET_N 	: in std_logic;

		-- GPIO, GPIO connect to GPIO Default
		GPIO : in std_logic_vector(35 downto 0)
	);
END top;

architecture top_arch of top is
	--declare component
	component full_adder 
		Port (A : in std_logic;
				B : in std_logic;
				Cin : in std_logic;
				S : out std_logic;
				Cout : out std_logic);
	end component;
	--declare signals
	signal C1, C2, C3, Z, Cout : std_logic;
	signal A : std_logic_vector (3 downto 0) := (others => '0');
	signal mux_out : std_logic_vector (3 downto 0);
	signal s : std_logic_vector (3 downto 0);
	
	begin
		--initiate four instances of components with different port maps to make ripple carry adder
		fa_1 : full_adder port map (SW(4), SW(0), SW(8), s(0), C1);
		fa_2 : full_adder port map (SW(5), SW(1), C1, s(1), C2);
		fa_3 : full_adder port map (SW(6), SW(2), C2, s(2), C3);
		fa_4 : full_adder port map (SW(7), SW(3), C3, s(3), Cout);
		
		--comparator output for value greater than 9
		z <= (s(1) AND s(3) AND NOT Cout) OR (s(2) AND s(3) AND NOT Cout) OR (NOT s(2) AND NOT s(3) AND Cout);
		
		--circuit A for outputting first digit to sevseg when comparator output z is high (for digits 10 to 19)
		A(0) <= (s(0) AND s(1) AND s(3) AND NOT Cout) OR (s(0) AND s(2) AND s(3) AND NOT Cout) OR (s(0) AND NOT s(2) AND NOT s(3) AND Cout);
		A(1) <= (NOT s(1) AND s(2) AND s(3) AND NOT Cout) OR (NOT s(1) AND NOT s(2) AND NOT s(3) AND Cout);
		A(2) <= (s(1) AND s(2) AND s(3) AND NOT Cout) OR (NOT s(1) AND NOT s(2) AND NOT s(3) AND Cout);
		A(3) <= (s(1) AND NOT s(2) AND NOT s(3) AND Cout);
		
		--output of mux dependant on ripple adder output s, or output from A, selected by comparator output z
		mux_out <= s(3 downto 0) when (z = '0') else A;

		--set value of second digit sevseg to one when output of comparator z is high
		HEX1 <= "11111001" when (z = '1') else "11000000";
		
		--boolean expressions for output of first digit sevseg
		HEX0(0) <= (mux_out(0) AND NOT mux_out(1) AND NOT mux_out(2) AND NOT mux_out(3)) OR (mux_out(2) AND NOT mux_out(1) AND NOT mux_out(0) AND NOT mux_out(3));
		HEX0(1) <= (mux_out(0) AND NOT mux_out(1) AND mux_out(2) AND NOT mux_out(3)) OR (NOT mux_out(0) AND mux_out(1) AND mux_out(2) AND NOT mux_out(3));
		HEX0(2) <= NOT mux_out(0) AND mux_out(1) AND NOT mux_out(2) AND NOT mux_out(3);
		HEX0(3) <= (mux_out(0) AND NOT mux_out(1) AND NOT mux_out(2) AND NOT mux_out(3)) OR (NOT mux_out(0) AND NOT mux_out(1) AND mux_out(2) AND NOT mux_out(3)) OR (mux_out(0) AND mux_out(1) AND mux_out(2) AND NOT mux_out(3));
		HEX0(4) <= (mux_out(0) AND NOT mux_out(3)) OR (mux_out(0) AND NOT mux_out(1) AND NOT mux_out(2)) OR (NOT mux_out(1) AND mux_out(2) AND NOT mux_out(3));
		HEX0(5) <= (mux_out(0) AND NOT mux_out(2) AND NOT mux_out(3)) OR (mux_out(1) AND NOT mux_out(2) AND NOT mux_out(3)) OR (mux_out(0) AND mux_out(1) AND NOT mux_out(3));
		HEX0(6) <= (NOT mux_out(1) AND NOT mux_out(2) AND NOT mux_out(3)) OR (mux_out(0) AND mux_out(1) AND mux_out(2) AND NOT mux_out(3));
		
end architecture;

